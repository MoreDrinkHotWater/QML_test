#include "LineRender.h"
#include "../../binding/WindowOpPara.h"
#include "configuration/common.h"
#include <iostream>
void LineRender::init(){

    this->name = "line";                //务必要设置名称
    m_program = new QOpenGLShaderProgram();

    static const char *vertexShaderSourceCore =
        "#version 130\n"
        "in vec4 vertex;\n"
         "in vec3 color;\n"
        "out vec3 vert;\n"
        "out vec3 f_color;"
        "uniform mat4 projMatrix;\n"
        "uniform mat4 mvMatrix;\n"
        "void main() {\n"
        "   vert = vertex.xyz;\n"
        "   f_color = color;\n"
        "   gl_Position = projMatrix * mvMatrix * vertex;\n"
        "}\n";

    static const char *fragmentShaderSourceCore =
        "#version 130\n"
        "#ifdef GL_ES \nprecision mediump float;\n#endif\n"
        "in highp vec3 f_color;\n"
        "out highp vec4 fragColor;\n"
         "void main() {\n"
        "   fragColor = vec4(f_color, 1.0);\n"
        "}\n";


        OpenGl *opengl = OpenGl::getInstance();

        m_program->addCacheableShaderFromSourceCode(QOpenGLShader::Vertex,opengl->mapShader(vertexShaderSourceCore,true)); //m_core

        m_program->addCacheableShaderFromSourceCode(QOpenGLShader::Fragment,opengl->mapShader(fragmentShaderSourceCore,false));


        m_program->bindAttributeLocation("vertex", 0);

        m_program->bindAttributeLocation("color", 1);

        m_program->link();

       
        m_projMatrixLoc = m_program->uniformLocation("projMatrix");

        m_mvMatrixLoc = m_program->uniformLocation("mvMatrix");

}

void LineRender::bind(void *dat){


    m_program->bind();

    WindowOpPara *winPara = WindowOpPara::getInstance();





    _gl->glEnable(GL_DEPTH_TEST);                   //不关这个，会无法正常更新显示 :(
    _gl->glDepthFunc(GL_LESS); //基准设置为 1.0，那么GL_LESS 则深度小余 1.0 的通过测试
    /*******************************************************/
 //    _gl->glFrontFace( GL_CCW );       //指定正面是哪一面
//    _gl->glEnable( GL_CULL_FACE );     //剃除正面或背面的显示,加快渲染
    _gl->glCullFace(GL_BACK);//GL_BACK GL_FRONT
    _gl->glDisable(GL_CULL_FACE);
     /*******************************************************/
//    _gl->glPolygonMode(GL_FRONT, GL_LINE);

    _gl->glDisable(GL_BLEND);
//    _gl->glBlendFunc(GL_ONE, GL_ZERO);
    if(dat)
        _gl->glLineWidth(*(float *)dat);// width为float类型值，在0~10.0，大于10以上按10来处理。
    else
        _gl->glLineWidth(0.1);
    _gl->glEnable(GL_LINE_SMOOTH);       //开启线的反走样

    m_program->setUniformValue(m_projMatrixLoc, winPara->m_proj);
    m_program->setUniformValue(m_mvMatrixLoc, winPara->m_camera * winPara->m_world);
    QMatrix3x3 normalMatrix = winPara->m_world.normalMatrix();
    m_program->setUniformValue(m_normalMatrixLoc, normalMatrix);



    m_program->enableAttributeArray(0);
    m_program->enableAttributeArray(1);
    glBufs.clear();
}

void LineRender::setDat(renderType_t type,void *para,int itemSize){
    vertexSize = itemSize/3;
    if(type == RENDER_LINE_COLOR){
        vertexSize = itemSize/6;
        m_program->setAttributeArray(0, (GLfloat *)para, 3,6 * sizeof(GLfloat));
        m_program->setAttributeArray(1, (GLfloat *)para + 3, 3,6 * sizeof(GLfloat));
    }else if(type == RENDER_LINE_COLOR_BUFFER){
        vertexSize = itemSize/6;
        glBufs.append((QOpenGLBuffer *)para);
        ((QOpenGLBuffer *)para)->bind();
        m_program->setAttributeBuffer(0,GL_FLOAT,0,3, 6 * sizeof(GLfloat));
        m_program->setAttributeBuffer(1,GL_FLOAT,3 * sizeof(GLfloat),3, 6 * sizeof(GLfloat));//int location, GLenum type, int offset, int tupleSize, int stride = 0

    }
}
void LineRender::render(){
    _gl->glDrawArrays(GL_LINES , 0, vertexSize);
}


void LineRender::release(){
    m_program->disableAttributeArray(0);
    m_program->disableAttributeArray(1);
    for(int i = 0; i < glBufs.size(); i ++){                //如果不释放，后续的非buf方式的画图会受到影响
        glBufs[i]->release();
    }
    m_program->release();
}


void LineRender::setExtraPara(void *para,QString opt){
    if(para)
        _gl->glEnable(GL_DEPTH_TEST);
    else{
        _gl->glDisable(GL_DEPTH_TEST);
    }
}
